# Programming in Scala

## Chapter 5

### 기본 타입

아래 표에서 스칼라의 여러 기본 타입과 그 인스턴스가 취할 수 있는 값의 범위를 확인할 수 있다. Byte, Short, Int, Long, Char같은 타입들을 **정수적인 타입(Integral Type)**이라고 한다. 이런 정수적인 타입들에, Float과 Double을 덧붙여서 **수 타입(Numeric Type)**이라 한다.

|   타입     |    범위                                  |
|:-----------|:-----------------------------------------|
|Byte       |8비트의 부호 있는 정수(-2^7 ~ 2^7 -1)       |
|Short      |16비트의 부호 있는 정수(-2^15 ~ 2^15 - 1)   |
|Int        |32비트의 부호 있는 정수(-2^31 ~ 2^31 - 1)   |
|Long       |64비트의 부호 있는 정수(-2^63 ~ 2^63 - 1)   |
|Char       |16비트의 부호 없는 유니코드 문자(0 ~ 2^16-1) |
|String     |Char의 시퀀스                              |
|Float      |32비트 IEEE 754 single-precision float    |
|Double     |64비트 IEEE 754 double-precision float    |

부호 있는 정수의 경우, 2의 보수 표현을 사용하여 표기한다. Java.lang 패키지의 String 타입을 제외하면, 모두 scala 패키지의 멤버이며, 자동으로 임포트된다. 이들(Byte, Short, Int, Long, Char, Float, Double)을 **값 타입(Value Type)**이라고도 부르며, 스칼라 컴파일러가 바이트 코드를 생성할때 대응하는 역할의 자바 원시 타입으로 자유롭게 변환할 수 있다.

### 리터럴

**리터럴(Literal)**은 상수 값을 코드에 직접 적는 방법을 의미한다. 위의 표의 모든 기본 타입들은 리터럴로 적을 수 있다. 여기선, 스칼라가 자바와 다른 부분만 살펴보겠다.

<!---
####정수 리터럴

- 0x, 0X로 시작하는 정수 리터럴 : 16진수
- 0이 아닌 숫자로 시작하는 정수 리터럴 : 10진수
- 정수 리터럴에 아무 장식이 없는 경우 : Int
- 정수 리터럴이 L혹은 l로 끝나는 경우 : Long
- Int 리터럴이 Short의 변수에 할당되고, 값이 Short의 범위 안인 경우 : Short로 취급
- Int 리터럴이 Byte의 변수에 할당되고, 값이 Byte의 범위 안인 경우 : Byte로 취급

####부동소수점(Floating Point) 리터럴

10진수 숫자가 소숫점을 포함하거나 E나 e 다음의 지수부분을 가진 경우, 부동소수점 리터럴이다. E와 e 다음에 숫자가 있는 경우, 그 숫자만큼의 10의 지수를 앞의 수에 곱한다. 아무런 표기가 없는(혹은 D나 d로 끝나는) 부동소수점 리터럴은 Double 타입이며, 리터럴이 F나 f로 끝난다면 Float 타입이다.

####문자 리터럴

작은따옴표 안에 유니코드 문자를 넣어 만든다. 또는 '\u'의 뒤에 유니코드 문자 코드 포인트(16진 숫자)를 추가하여 표현할 수도 있다. 이런 표현을 식별자 이름을 정하는데 사용하는 것도 가능하다.

```Scala
val B\u0041\u0044 = 1       //val BAD = 1
```

이러한 표현을 지원하는 이유는, ASCII 코드가 아닌 유니코드 문자가 들어간 스칼라 소스 파일을 아스키 문자만으로 표현하기 위해서 이다.

스칼라는 또한 특수한 Escape Sequence들로 표현 가능한 문자들을 가지고 있다.

|리터럴  |   의미           |
|:------|:-----------------|
|\n     |줄 바꿈            |
|\b     |백스페이스          |
|\t     |탭                  |
|\f     |폼 피드(페이지 넘김) |
|\r     |캐리지 리턴(줄 맨 앞으로)|
|\"     |큰 따옴표          |
|\'     |작은 따옴표         |
|\\     |역슬래시           |

-->

####문자열 리터럴

문자열 리터럴은 큰따옴표(")로 둘러쌓인 문자들로 이루어진다. 이 문자들의 문법은 문자 리터럴과 동일하다(이스케이프 시퀀스의 적용 등). 이스케이프 시퀀스가 많거나 여러 줄에 걸친 문자열의 경우, 이런 문법을 사용해 문자열을 표기하면 읽기 어렵다. 따라서, 스칼라에는 **Raw 문자열**을 위한 특별한 문법이 추가되어 있다. 이러한 Raw 문자열은 큰 따옴표 3개를 연속으로 사용해(""") 시작하며, 이 내부의 문자들이 그대로 문자열이 된다.

```Scala
println("""Hello this is
        Scala""")
```

위의 프로그램을 실행시 다음과 같은 결과물이 나온다.

```Console
Hello this is
        Scala
```

이는 두번째 줄 앞의 공백들도 문자열에 들어갔기 때문이다. 이를 없애기 위해서는, 파이프 문자(|)를 각 줄의 시작 부분에 넣은 뒤 stripMargin 메소드를 그 문자열에 대해 호출해야 한다.

```Scala
println("""|Hello this is
           |Scala""".stripMargin)
```

위의 프로그램을 실행시 다음과 같은 결과물이 나온다.

```Console
Hello this is
Scala
```

#### 심볼 리터럴

**심볼(Symbol)**은 **인턴(Intern)**된 스트링이다. 같은 심볼 리터럴을 두번 사용하면, 두 표현식 모두 완전히 동일한 Symbol 객체를 참조한다. 심볼은 다음과 같이 정의한다.

```Scala
val s = 'newSymbol
s.name                  //newSymbol이란 String
```

s는 newSymbol이란 String 이름을 가진 심볼이다. 심볼 리터럴은, 동적으로 타입이 정해지는 언어였다면 단순 식별자를 사용할 만한 경우에 사용된다(데이터베이스의 key 등).